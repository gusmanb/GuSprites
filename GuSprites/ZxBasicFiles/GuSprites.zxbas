'CONFIG DEFINES

'Enabling this define tells the library that we are going to use precomputed sprites.
'Using precomputed sprites will help to reduce the library's memory footprint when
'your program is going to use a single sprite set.
'To generate the precomputed sprites I recommend to use the ResourceDesigner program
'that you will find in my Github repository (https://github.com/gusmanb/ResourceDesigner).
' 
'Remember to modify also the include that is defined at the bottom of the 
'assembler variable declarations if your file is not named "Sprites.zxbas".

'#define PRECOMPUTED_SPRITES

'Enabling this define changes the merge of the sprites and tiles to be a XOR instead of an OR
'#define MERGE_WITH_XOR

'Enabling this define activates the fast print routines
#define ENABLE_PRINT

#define ENABLE_1x1_SPRITES
#define ENABLE_1x2_SPRITES
#define ENABLE_2x2_SPRITES

'Total number of 1x1 defined sprites
#define TOTAL_1x1_SPRITES 4
'Total number of 1x2 defined sprites
#define TOTAL_1x2_SPRITES 8
'Total number of 2x2 defined sprites
#define TOTAL_2x2_SPRITES 4

'Maximum on-screen 1x1 sprites
#define ONSCREEN_1x1_SPRITES 4
'Maximum on-screen 1x2 sprites
#define ONSCREEN_1x2_SPRITES 4
'Maximum on-screen 2x2 sprites
#define ONSCREEN_2x2_SPRITES 4

'If defined enables the tile system in its basic mode (tiles erased when sprite enters on it)
#define ENABLE_TILES
'If defined tiles are merged with OR instead of erased
'Requires ENABLE_TILES
#define MERGE_TILES

'The lib by default disables interrupts, enabling this option
'will reactivate them after each call to the lib
#define ENABLE_INTERRUPTS


asm

;MACROS

#ifdef MERGE_WITH_XOR
#define MERGE_OP xor
#else
#define MERGE_OP or
#endif

#define CREATE_ATTRIB(ink, paper, bright, flash) (ink + (paper << 3) + (bright << 6) + (flash << 7))

#define READ_HL_POINTER(Hi,Lo) \
ld Lo, (hl) \
inc hl \
ld Hi, (hl) \
inc hl \


#define WRITE_HL_POINTER(Hi, Lo) \
ld (hl), Lo \
inc hl \
ld (hl), Hi \
inc hl \


#define WRITE_16B_ADDRESS(value, target, temp) \
ld temp, value \
ld (target), temp \


#define EXCHANGE_16B_A(regAH, regAL, regBH, regBL) \
ld a, regAH \
ld regAH, regBH \
ld regBH, a \
ld a, regAL \
ld regAL, regBL \
ld regBL, a \

#define COPY_16B_REG(sourceH, sourceL, destH, destL) \
ld destH, sourceH \
ld destL, sourceL \


#define ERASE_MEMORY(address, length) \
xor a \
ld de, address \
ld (de), a \
inc de \
ld hl, address \
ld bc, length - 1 \
ldir \


#define SHIFT_24B(first,second,third) \
srl first \
rr second \
rr third \
srl first \
rr second \
rr third \
srl first \
rr second \
rr third \
srl first \
rr second \
rr third \


#define MERGE_CHAR(source, dest) \
ld a, (source) \
MERGE_OP (dest) \
ld (dest),  a \
inc source \
inc dest \
ld a, (source) \
MERGE_OP (dest) \
ld (dest),  a \
inc source \
inc dest \
ld a, (source) \
MERGE_OP (dest) \
ld (dest),  a \
inc source \
inc dest \
ld a, (source) \
MERGE_OP (dest) \
ld (dest),  a \
inc source \
inc dest \
ld a, (source) \
MERGE_OP (dest) \
ld (dest),  a \
inc source \
inc dest \
ld a, (source) \
MERGE_OP (dest) \
ld (dest),  a \
inc source \
inc dest \
ld a, (source) \
MERGE_OP (dest) \
ld (dest),  a \
inc source \
inc dest \
ld a, (source) \
MERGE_OP (dest) \
ld (dest),  a \


#define HL_POW2_2() \
add hl, hl \
add hl, hl \


#define HL_POW2_3() \
add hl, hl \
add hl, hl \
add hl, hl \


#define HL_POW2_4() \
add hl, hl \
add hl, hl \
add hl, hl \
add hl, hl \


#define HL_POW2_5() \
add hl, hl \
add hl, hl \
add hl, hl \
add hl, hl \
add hl, hl \

#define LDI_8() \
ldi \
ldi \
ldi \
ldi \
ldi \
ldi \
ldi \
ldi \

;LIB DEFINES

#ifndef ENABLE_1x1_SPRITES

    #define TOTAL_1x1_SPRITES 0
    #define ONSCREEN_1x1_SPRITES 0

#endif

#ifndef ENABLE_1x2_SPRITES

    #define TOTAL_1x2_SPRITES 0
    #define ONSCREEN_1x2_SPRITES 0

#endif

#ifndef ENABLE_2x2_SPRITES

    #define TOTAL_2x2_SPRITES 0
    #define ONSCREEN_2x2_SPRITES 0

#endif

#define ROM_CHARSET 3C00h

SPRITE_1x1_BUFFER_SIZE equ (6 * 8)
SPRITE_1x2_BUFFER_SIZE equ (9 * 8)
SPRITE_2x2_BUFFER_SIZE equ (15 * 8)

SPRITE_1x1_SHIFTED_SIZE equ 4
SPRITE_1x2_SHIFTED_SIZE equ 6
SPRITE_2x2_SHIFTED_SIZE equ 9

TOTAL_1x1_OPS equ (ONSCREEN_1x1_SPRITES * SPRITE_1x1_SHIFTED_SIZE)
TOTAL_1x2_OPS equ (ONSCREEN_1x2_SPRITES * SPRITE_1x2_SHIFTED_SIZE)
TOTAL_2x2_OPS equ (ONSCREEN_2x2_SPRITES * SPRITE_2x2_SHIFTED_SIZE)

TOTAL_DRAW_OPS equ ((TOTAL_1x1_OPS + TOTAL_1x2_OPS + TOTAL_2x2_OPS) * 2)

#ifdef ENABLE_TILES
DRAW_OP_SIZE equ 5
#else
DRAW_OP_SIZE equ 4
#endif

DRAW_OPS_SIZE equ (TOTAL_DRAW_OPS * DRAW_OP_SIZE)
DRAW_OPS_DATA_SIZE equ (TOTAL_DRAW_OPS * 8)

SPRITE_BUFFER_SIZE equ ((TOTAL_1x1_SPRITES * SPRITE_1x1_BUFFER_SIZE)+(TOTAL_1x2_SPRITES * SPRITE_1x2_BUFFER_SIZE)+(TOTAL_2x2_SPRITES * SPRITE_2x2_BUFFER_SIZE))
SPRITE_INDEX_SIZE equ ((TOTAL_1x1_SPRITES + TOTAL_1x2_SPRITES + TOTAL_2x2_SPRITES + 1) * 2)



;JUMP TO PROG START
jp GSPRITES_LIB_END

;draw op structure:
;
;non-tiled:
;0x00 = Screen Address
;0x02 = Buffer address
;
;tiled.
;0x00 = Screen Address
;0x02 = Buffer address
;0x04 = op type (draw op = 1, tile clear op = 2)


;VARIABLES

DRAW_OPS_A:                 ;buffer de operaciones A
defs DRAW_OPS_SIZE

DRAW_OPS_B:                 ;buffer de operaciones B
defs DRAW_OPS_SIZE

DRAW_OPS_DATA:              ;buffer de datos de operaciones
defs DRAW_OPS_DATA_SIZE

CURRENT_DRAW_OPS:           ;puntero a las ops actuales
defw 0
CURRENT_CLEAR_OPS:          ;puntero a las ops de limpieza actuales
defw 0

CURRENT_DRAW_COUNT:         ;cantidad de ops actuales
defb 0
CURRENT_CLEAR_COUNT:        ;cantidad de ops de borrado actuales
defb 0

DRAW_OPS_DATA_INDEX:        ;índice de posición de escritura
defw 0

CELL_MAP_A:                 ;mapa de celdas A
defs (32 * 24)
CELL_MAP_B:                 ;mapa de celdas B
defs (32 * 24)

CURRENT_DRAW_MAP:           ;puntero a uno de los mapas de celdas que se usa para almacenar las id's de operaciones de dibujado por su posición
defw 0
CURRENT_CLEAR_MAP:          ;puntero a uno de los mapas de celdas que se usa para almacenar las id's de operaciones de limpieza por su posición
defw 0

#ifndef PRECOMPUTED_SPRITES

SPRITE_BUFFER:              ;shifted sprite buffer
defs SPRITE_BUFFER_SIZE
SPRITE_INDEX:               ;shifted sprite indexes (stores address of each sprite)
defs SPRITE_INDEX_SIZE
SPRITE_COUNT:               ;number of created sprites
defb 0

#else

end asm

    #include "Sprites.zxbas"

asm

#endif

#ifndef ENABLE_TILES
EMPTY_CHAR:
defs 8
#endif

#ifdef ENABLE_TILES
TILE_SET:
defw 0
TILE_MAP:
defs 768
#endif


;CODE

PROC 
INIT_GFX_LIB:                       ;TRASHES: HL

#ifndef ENABLE_INTERRUPTS
    di
#endif

WRITE_16B_ADDRESS(DRAW_OPS_A, CURRENT_DRAW_OPS, hl)
WRITE_16B_ADDRESS(DRAW_OPS_B, CURRENT_CLEAR_OPS, hl)

WRITE_16B_ADDRESS(DRAW_OPS_DATA, DRAW_OPS_DATA_INDEX, hl)

WRITE_16B_ADDRESS(CELL_MAP_A, CURRENT_DRAW_MAP, hl)
WRITE_16B_ADDRESS(CELL_MAP_B, CURRENT_CLEAR_MAP, hl)

WRITE_16B_ADDRESS(SPRITE_BUFFER, SPRITE_INDEX, hl)

ret
ENDP

PROC
RESET_GFX_LIB:                      ;TRASHES: HL, A

WRITE_16B_ADDRESS(DRAW_OPS_A, CURRENT_DRAW_OPS, hl)
WRITE_16B_ADDRESS(DRAW_OPS_B, CURRENT_CLEAR_OPS, hl)

WRITE_16B_ADDRESS(CELL_MAP_A, CURRENT_DRAW_MAP, hl)
WRITE_16B_ADDRESS(CELL_MAP_B, CURRENT_CLEAR_MAP, hl)

WRITE_16B_ADDRESS(DRAW_OPS_DATA, DRAW_OPS_DATA_INDEX, hl)

#ifndef PRECOMPUTED_SPRITES
ERASE_MEMORY(SPRITE_BUFFER, SPRITE_BUFFER_SIZE)
WRITE_16B_ADDRESS(SPRITE_BUFFER, SPRITE_INDEX, hl)
xor a
ld (SPRITE_COUNT), a
#endif

xor a
ld (CURRENT_DRAW_COUNT), a
ld (CURRENT_CLEAR_COUNT), a

ERASE_MEMORY(CELL_MAP_A, 768)
ERASE_MEMORY(CELL_MAP_B, 768)

#ifdef ENABLE_TILES
ERASE_MEMORY(TILE_MAP, 768)
#endif

ret
ENDP

PROC
CLEAR_SCREEN:                      ;TRASHES: HL, A

WRITE_16B_ADDRESS(DRAW_OPS_A, CURRENT_DRAW_OPS, hl)
WRITE_16B_ADDRESS(DRAW_OPS_B, CURRENT_CLEAR_OPS, hl)

WRITE_16B_ADDRESS(CELL_MAP_A, CURRENT_DRAW_MAP, hl)
WRITE_16B_ADDRESS(CELL_MAP_B, CURRENT_CLEAR_MAP, hl)

WRITE_16B_ADDRESS(DRAW_OPS_DATA, DRAW_OPS_DATA_INDEX, hl)

xor a
ld (CURRENT_DRAW_COUNT), a
ld (CURRENT_CLEAR_COUNT), a

ERASE_MEMORY(CELL_MAP_A, 768)
ERASE_MEMORY(CELL_MAP_B, 768)

#ifdef ENABLE_TILES
ERASE_MEMORY(TILE_MAP, 768)
#endif

ret
ENDP

PROC
LOCAL RENDER_LOOP, END_RENDER, RESTORE_STACK
RENDER_FRAME:                                         ;TRASHES: BC, DE, HL, A

#ifndef ENABLE_INTERRUPTS
ei
#endif
halt
#ifndef ENABLE_INTERRUPTS
di
#endif


ld a, (CURRENT_DRAW_COUNT)
cp 0
jp z, END_RENDER

ld hl, (CURRENT_DRAW_OPS)
push hl

RENDER_LOOP:

pop hl                      ;get current op address

READ_HL_POINTER(d,e)    ;get op target
READ_HL_POINTER(b,c)    ;get op source

#ifdef ENABLE_TILES
inc hl
#endif

push hl                     ;store current op address

COPY_16B_REG(b,c, h,l)        ;hl = source, de = target, stack = op address

ld (RESTORE_STACK + 1), sp      ;save stack address
ld sp, hl                       ;point stack to the op data
ex de, hl

pop de                      ;extract two bytes of data
ld (hl), e                  ;load first byte
inc h                       ;increase target address
ld (hl), d                  ;load second byte
inc h                       ;increase target address
pop de                      ;extract two bytes of data
ld (hl), e                  ;load first byte
inc h                       ;increase target address
ld (hl), d                  ;load second byte
inc h                       ;increase target address
pop de                      ;extract two bytes of data
ld (hl), e                  ;load first byte
inc h                       ;increase target address
ld (hl), d                  ;load second byte
inc h                       ;increase target address
pop de                          ;extract two bytes of data
ld (hl), e                      ;load first byte
inc h                           ;increase target address
ld (hl), d                      ;load second byte

RESTORE_STACK:
ld sp, 0                    ;Retore the data stack as we were using it for copy

;more ops left?
ld hl, CURRENT_DRAW_COUNT
dec (hl)
jp nz, RENDER_LOOP

;no, clear stack
pop bc


END_RENDER:
;frame end, swap data

ld bc, (CURRENT_DRAW_OPS)   ;swap draw and clear op
ld de, (CURRENT_CLEAR_OPS)
ld (CURRENT_DRAW_OPS), de
ld (CURRENT_CLEAR_OPS), bc

ld de, (CURRENT_DRAW_MAP)   ;swap draw and clear maps
ld bc, (CURRENT_CLEAR_MAP)
ld (CURRENT_DRAW_MAP), bc
ld (CURRENT_CLEAR_MAP), de

xor a
push de                     ;clear map
ld (de), a
inc de
pop hl
ld bc, 767
ldir

ld a, (CURRENT_CLEAR_COUNT) ;swap draw count and erase clear count
ld (CURRENT_DRAW_COUNT), a
xor a
ld (CURRENT_CLEAR_COUNT), a

WRITE_16B_ADDRESS(DRAW_OPS_DATA, DRAW_OPS_DATA_INDEX, hl) ; reset op index

ret
ENDP

#ifndef PRECOMPUTED_SPRITES

PROC
CREATE_SPRITE_BUFFER:          ;input: bc = buffer sze, output: hl = sprite buffer address, trash = bc, de, hl, a

ld a, (SPRITE_COUNT)
add a, a
ld e, a
ld d, 0
ld hl, SPRITE_INDEX
add hl, de

READ_HL_POINTER(d,e)         ;load in DE the data address
                            ;hl = next index, de = data start
push de

ex de, hl
add hl, bc
ex de, hl

WRITE_HL_POINTER(d,e)        ;store in index the next buffer start address

ld hl, SPRITE_COUNT         ;incrementar cuenta de sprites
inc (hl)

pop hl

ret
ENDP

#ifdef ENABLE_1x1_SPRITES

PROC
LOCAL LOOP
CREATE_1x1_SPRITE:          ;input: hl = sprite address, output: a = sprite number (base 1); trash= bc, de, hl, a

push hl
ld bc, SPRITE_1x1_BUFFER_SIZE
call CREATE_SPRITE_BUFFER   ;create buffer

ld de, 4
add hl, de                  ;skip padding bytes

pop de                      ;restore source address and preserve it again
push de

ex de, hl

LDI_8()
;ld bc, 8
;ldir                        ;copy the sprite

ld hl, 8                    ;skip bottom padding and upper padding of next column
add hl, de

ex de, hl
pop hl                      ;hl = source, de = dest

ld ixh, d                   ;copy dest to ix
ld ixl, e

ld b, 8

LOOP:

ld e, (hl)              ;load and shift byte to two bytes
ld d, 0
inc hl
ex de, hl
HL_POW2_4()
ex de, hl

ld (ix+0), d            ;write both bytes to the sprite
ld (ix+16), e
inc ix

djnz LOOP

ld a, (SPRITE_COUNT)      ;read sprite number

ret
ENDP

#endif

#ifdef ENABLE_1x2_SPRITES

PROC
LOCAL LOOP
CREATE_1x2_SPRITE:

push hl
ld bc, SPRITE_1x2_BUFFER_SIZE
call CREATE_SPRITE_BUFFER   ;create buffer

ld de, 4
add hl, de                  ;skip padding bytes

pop de                      ;restore source address and preserve it again
push de

ex de, hl

LDI_8()
LDI_8()

;ld bc, 16
;ldir                        ;copy the sprite

ld hl, 8                    ;skip bottom padding and upper padding of next column
add hl, de

ex de, hl
pop hl                      ;hl = source, de = dest

ld ixh, d                   ;copy dest to ix
ld ixl, e

ld b, 16

LOOP:

ld e, (hl)              ;load and shift byte to two bytes
ld d, 0
inc hl
ex de, hl
HL_POW2_4()
ex de, hl

ld (ix+0), d            ;write both bytes to the sprite
ld (ix+24), e
inc ix

djnz LOOP

ld a, (SPRITE_COUNT)      ;read sprite number

ret

ENDP

#endif

#ifdef ENABLE_2x2_SPRITES

PROC
LOCAL LOOP
CREATE_2x2_SPRITE:

push hl
ld bc, SPRITE_2x2_BUFFER_SIZE
call CREATE_SPRITE_BUFFER   ;create buffer

ld de, 4
add hl, de                  ;skip padding bytes

pop de                      ;restore source address and preserve it again
push de

ex de, hl

LDI_8()
LDI_8()
;ld bc, 16
;ldir                        ;copy the sprite

ex de, hl
ld bc, 8
add hl, bc

ex de, hl

LDI_8()
LDI_8()
;ld bc, 16
;ldir

ld hl, 8                    ;skip bottom padding and upper padding of next column
add hl, de
ex de, hl

pop iy                      ;iy = source, hl = dest

ld ixh, d                   ;copy dest to ix
ld ixl, e

ld b, 16

LOOP:

ld c, (iy+0)              ;load and shift
ld d, (iy+16)
ld e, 0

SHIFT_24B(c,d,e)

ld (ix+0), c                ;save shifted sprite
ld (ix+24), d
ld (ix+48), e

inc iy                      ;next src/target
inc ix

djnz LOOP

ld a, (SPRITE_COUNT)      ;read sprite number

ret
ENDP

#endif

#endif

PROC
LOCAL EXISTING_OP, REAL_EXISTING_OP
CREATE_DRAW_OP:                             ;input: b = xrow, c = ycol, hl=sprite data address. Trashes hl, bc, de, a, ix, iy

;creates a draw op using the char data at de

push hl
push bc

ld l, c                                     
ld h, 0

HL_POW2_5()                                  ;ycol * 32

ld c, b                                     ;+ xrow
ld b, 0

add hl, bc                                  ;hl cointains displacement in map

ld de, (CURRENT_DRAW_MAP)

push hl                                     ;preserve displacement

add hl, de                                  ;advance pointer to concrete cell

ld a, (hl)
and a
jp nz, EXISTING_OP                          ;a = num op

ld a, (CURRENT_DRAW_COUNT)                  ;load current draw op count
inc a                                       ;increase op number
ld (CURRENT_DRAW_COUNT), a                  ;store it in 
ld (hl), a
dec a                                       ;draw count is 1 based, not 0, so decrease 1

ld l, a
ld h, 0

#ifdef ENABLE_TILES

COPY_16B_REG(h,l, d,e)
HL_POW2_2()
add hl, de

#else
HL_POW2_2()                                   ;hl = offset, a = numop
#endif

ld bc, (CURRENT_DRAW_OPS)
add hl, bc                                  ;get current op address

pop de
pop bc
push de                                     ;hl = op address, bc = coords, stack = displacement

ld a, c
and %00011000
or  %01000000
ld d, a
ld a, c
and %00000111
rla
rla
rla
rla
rla
or b
ld e, a                                     ;de = screen address

ld ixh, d                                   ;preserve it in iy
ld ixl, e

WRITE_HL_POINTER(d,e)                        ;store it in op

ld de, (DRAW_OPS_DATA_INDEX)

ld iyh, d                                   ;preserve it in iy
ld iyl, e

WRITE_HL_POINTER(d,e)                        ;store op data address in op


#ifdef ENABLE_TILES
;ld a, 1                                     ;tag this as real op
ld (hl), 1
#endif


ld l, 8                                     ;add 8 bytes of op
ld h, 0
add hl, de

ld (DRAW_OPS_DATA_INDEX), hl                ;preserve data index

;now, create the clear op

pop bc
ld hl, (CURRENT_CLEAR_MAP)

add hl, bc                                  ;advance pointer to concrete cell

ld a, (CURRENT_CLEAR_COUNT)
inc a
ld (CURRENT_CLEAR_COUNT), a                 ;update clear count
ld (hl), a                                  ;store num op in clear map
dec a                                       ;draw count is 1 based, not 0, so decrease 1

ld l, a                                     ;compute op dispplacement
ld h, 0

#ifdef ENABLE_TILES
COPY_16B_REG(h,l, d,e)
HL_POW2_2()                                  ;num * 5
add hl, de

#else

HL_POW2_2()                                  ; num * 4

#endif

ld de, (CURRENT_CLEAR_OPS)                  ;get op address
add hl, de

ld d, ixh                                   ;restore screen address from ix
ld e, ixl

WRITE_HL_POINTER(d,e)                        ;store screen address

#ifdef ENABLE_TILES

ex de, hl                                   ;de contains pointer to op
ld hl, TILE_MAP                             ;load tile map address
add hl, bc                                  ;add displacement
ld a, (hl)

ld l, a
ld h, 0

HL_POW2_3()

ld bc, (TILE_SET)
add hl, bc
ex de, hl

WRITE_HL_POINTER(d,e)                        ;store data address

;ld a, 2                                     ;tag this as clear op
ld (hl), 2

#else


ld de, EMPTY_CHAR
WRITE_HL_POINTER(d,e)                        ;store data address

#endif


pop hl


#ifdef MERGE_TILES


ld b, iyh
ld c, iyl
;de = tile source, bc = buffer, hl = sprite address

;hl = sprite address, de = buffer address, bc = tile address

ld a, (de)
    MERGE_OP (hl)
    ld (bc), a
    inc bc
    inc de
    inc hl
ld a, (de)
    MERGE_OP (hl)
    ld (bc), a
    inc bc
    inc de
    inc hl
ld a, (de)
    MERGE_OP (hl)
    ld (bc), a
    inc bc
    inc de
    inc hl
ld a, (de)
    MERGE_OP (hl)
    ld (bc), a
    inc bc
    inc de
    inc hl
ld a, (de)
    MERGE_OP (hl)
    ld (bc), a
    inc bc
    inc de
    inc hl
ld a, (de)
    MERGE_OP (hl)
    ld (bc), a
    inc bc
    inc de
    inc hl
ld a, (de)
    MERGE_OP (hl)
    ld (bc), a
    inc bc
    inc de
    inc hl

    ld a, (de)
    MERGE_OP (hl)
    ld (bc), a

#else
ld d, iyh                                   ;finally, we copy the char data to the op
ld e, iyl

LDI_8()
;ld bc, 8
;ldir
#endif

ret 

EXISTING_OP:                                ;a = op number

dec a

ld l, a
ld h, 0

#ifdef ENABLE_TILES

COPY_16B_REG(h,l, d,e)
HL_POW2_2()
add hl, de

#else
HL_POW2_2()                                   ;hl = offset, a = numop
#endif

ld bc, (CURRENT_DRAW_OPS)

add hl, bc                                  ;get current op address

READ_HL_POINTER(b,c)                         ;store screen address

push hl                                     ;store op address
push bc                                     ;store screen address

READ_HL_POINTER(d,e)                         ;de contains the data address

#ifdef ENABLE_TILES

push de                                     ;store tile address

ld a, (hl)
and 2
jp z, REAL_EXISTING_OP
;ld a, 1
ld (hl), 1
#else

ld hl, EMPTY_CHAR
sbc hl, de                                  ;test if address is the empty char
jp nz, REAL_EXISTING_OP

#endif

;this was a clear op
;create the clear op for the new op

;stack contains:
;screen address
;op address
;displacement
;coordinates
;sprite address

#ifdef ENABLE_TILES
pop af
#endif

pop bc                          ;screen address
pop de                          ;op address
pop hl                          ;displacement
push de

#ifdef ENABLE_TILES
push af
#endif

;stack contains:
;displacement (only if tiles enabled)
;op address
;coordinates
;sprite address

ld de, (CURRENT_CLEAR_MAP)
add hl, de                      ;add displacement to the map coords

ld a, (CURRENT_CLEAR_COUNT)     ;read current clear count
inc a                           ;increment it
ld (hl), a                      ;store it in the map
ld (CURRENT_CLEAR_COUNT), a     ;update variable

dec a                           ;get clear op address
ld l, a
ld h, 0

#ifdef ENABLE_TILES

COPY_16B_REG(h,l, d,e)
HL_POW2_2()
add hl, de

#else
HL_POW2_2()                                   ;hl = offset, a = numop
#endif

ld de, (CURRENT_CLEAR_OPS)
add hl, de

WRITE_HL_POINTER(b,c)            ;store screen address

#ifdef ENABLE_TILES

pop de
WRITE_HL_POINTER(d,e)                        ;store data address

;ld a, 2                                     ;tag this as clear op
ld (hl), 2

#else


ld de, EMPTY_CHAR
WRITE_HL_POINTER(d,e)                        ;store data address

#endif

pop hl

#ifdef MERGE_TILES
push de
#endif

ld de, (DRAW_OPS_DATA_INDEX)

;push de                                     ;store buffer address

WRITE_HL_POINTER(d,e)                        ;store data address in op

ld hl, 8
add hl, de

ld (DRAW_OPS_DATA_INDEX), hl                ;increment data index

#ifdef MERGE_TILES
pop bc                                      ;restore source address
#endif

pop hl                                      ;clear stack
pop hl                                      ;copy the data to the op

#ifdef MERGE_TILES

;hl = sprite address, de = buffer address, bc = tile address

ld a, (bc)
    MERGE_OP (hl)
    ld (de), a
    inc bc
    inc de
    inc hl
ld a, (bc)
    MERGE_OP (hl)
    ld (de), a
    inc bc
    inc de
    inc hl
ld a, (bc)
    MERGE_OP (hl)
    ld (de), a
    inc bc
    inc de
    inc hl
ld a, (bc)
    MERGE_OP (hl)
    ld (de), a
    inc bc
    inc de
    inc hl
ld a, (bc)
    MERGE_OP (hl)
    ld (de), a
    inc bc
    inc de
    inc hl
ld a, (bc)
    MERGE_OP (hl)
    ld (de), a
    inc bc
    inc de
    inc hl
ld a, (bc)
    MERGE_OP (hl)
    ld (de), a
    inc bc
    inc de
    inc hl

    ld a, (bc)
    MERGE_OP (hl)
    ld (de), a

#else
LDI_8()
;ld bc, 8
;ldir
#endif

ret

REAL_EXISTING_OP:                           ;not empty char

pop hl                                      ;clear stack
pop hl                                      ;clear stack
pop hl                                      ;clear stack
pop hl                                      ;clear stack

#ifdef ENABLE_TILES
pop hl                                      ;clear stack
#endif

pop hl                                      ;retrieve sprite address

ex de, hl

MERGE_CHAR(de, hl)                          ;merge op

ret

ENDP


PROC
LOCAL LOOP
DRAW_SPRITE_COLUMN:         ;input: hl = column start address, bc = coordinates, a = column char height

LOOP

push hl
push bc
ex af, af'

call CREATE_DRAW_OP

pop bc
pop hl

inc c
ld de, 8
add hl, de

ex af, af'

dec a
jr nz, LOOP

ret
ENDP

#ifdef ENABLE_1x1_SPRITES

PROC
LOCAL TEST_SHIFTS, HORIZONTAL_SHIFT, VERTICAL_SHIFT
DRAW_1x1_SPRITE:            ;input: a = sprite number, b=x, c=y

dec a
add a, a
ld l, a
ld h, 0
ld de, SPRITE_INDEX
add hl, de

READ_HL_POINTER(d,e)    ;de contains the sprite data

ld a, b
or c
and 1

jp nz, TEST_SHIFTS

;unshifted sprite
srl b                       ;calculate row/col
srl c

ld hl, 4
add hl, de                  ;hl = sprite data address

call CREATE_DRAW_OP         ;create op

ret

TEST_SHIFTS:
ld a, c
and 1
jp z, HORIZONTAL_SHIFT
ld a, b
and 1
jp z, VERTICAL_SHIFT

;diagonal shift

srl b                       ;calculate row/col
srl c

ld hl, 16
add hl, de

push bc                     ;store coords
;push hl                     ;store data address

ld a, 2
call DRAW_SPRITE_COLUMN

ld a,2
pop bc
inc b
call DRAW_SPRITE_COLUMN

ret

HORIZONTAL_SHIFT:

srl b                       ;calculate col/row
srl c

ld hl, 20                   ;skip 32 bytes; 12 bytes of padding and 1 char
add hl, de                  ;hl now contains first line of real data

push bc                     ;store coords
push hl                     ;store data address

call CREATE_DRAW_OP         ;create first op

pop hl
pop bc                      ;restore col/row
inc b                       ;next col


ld de, 16                   ;skip 16 bytes, 8 bytes of padding and one char
add hl, de

call CREATE_DRAW_OP         ;create second op

ret

VERTICAL_SHIFT:

srl b                       ;calculate row/col
srl c

ex de, hl
ld a, 2
call DRAW_SPRITE_COLUMN

ret
ENDP

#endif

#ifdef ENABLE_1x2_SPRITES

PROC
LOCAL TEST_SHIFTS, HORIZONTAL_SHIFT, VERTICAL_SHIFT
DRAW_1x2_SPRITE:            ;input: a = sprite number, b=x, c=y

dec a
add a, a
ld l, a
ld h, 0
ld de, SPRITE_INDEX
add hl, de

READ_HL_POINTER(d,e)    ;de contains the sprite data

ld a, b
or c
and 1

jp nz, TEST_SHIFTS

;unshifted sprite
srl b                       ;calculate row/col
srl c

ld hl, 4
add hl, de                  ;hl = sprite data address

ld a, 2
call DRAW_SPRITE_COLUMN

ret

TEST_SHIFTS:
ld a, c
and 1
jp z, HORIZONTAL_SHIFT
ld a, b
and 1
jp z, VERTICAL_SHIFT

;diagonal shift

srl b                       ;calculate row/col
srl c

ld hl, 24
add hl, de

push bc                     ;store coords
ld a, 3
call DRAW_SPRITE_COLUMN

ld a,3
pop bc
inc b
call DRAW_SPRITE_COLUMN

ret

HORIZONTAL_SHIFT:

srl b                       ;calculate col/row
srl c

ld hl, 28                   ;skip 32 bytes; 12 bytes of padding and 1 char
add hl, de                  ;hl now contains first line of real data

push bc                     ;store coords
ld a,2
call DRAW_SPRITE_COLUMN     ;create first column

pop bc                      ;restore col/row
inc b                       ;next col
ld de, 8                    ;skip padding
add hl, de
ld a, 2
call DRAW_SPRITE_COLUMN         ;create second op

ret

VERTICAL_SHIFT:

srl b                       ;calculate row/col
srl c

ex de, hl
ld a, 3
call DRAW_SPRITE_COLUMN

ret
ENDP

#endif

#ifdef ENABLE_2x2_SPRITES

PROC
DRAW_2x2_SPRITE:            ;input: a = sprite number

dec a
add a, a
ld l, a
ld h, 0
ld de, SPRITE_INDEX
add hl, de

READ_HL_POINTER(d,e)    ;de contains the sprite data

ld a, b
or c
and 1

jp nz, TEST_SHIFTS

;unshifted sprite
srl b                       ;calculate row/col
srl c

ld hl, 4
add hl, de                  ;hl = sprite data address

push bc

ld a, 2
call DRAW_SPRITE_COLUMN

pop bc
inc b
ld de, 8
add hl, de
ld a, 2
call DRAW_SPRITE_COLUMN

ret

TEST_SHIFTS:
ld a, c
and 1
jp z, HORIZONTAL_SHIFT
ld a, b
and 1
jp z, VERTICAL_SHIFT

;diagonal shift

srl b                       ;calculate row/col
srl c

ld hl, 48
add hl, de

push bc                     ;store coords
ld a, 3
call DRAW_SPRITE_COLUMN     ;draw column

ld a,3                      ;next column
pop bc
inc b
push bc
call DRAW_SPRITE_COLUMN

ld a,3                      ;last column
pop bc
inc b
call DRAW_SPRITE_COLUMN

ret

HORIZONTAL_SHIFT:

srl b                       ;calculate col/row
srl c

ld hl, 52                   ;skip 32 bytes; 12 bytes of padding and 1 char
add hl, de                  ;hl now contains first line of real data

push bc                     ;store coords
ld a,2                      ;column is 2 chars height
call DRAW_SPRITE_COLUMN     ;create first column

pop bc                      ;restore col/row
inc b                       ;next col
push bc                     ;store for next col
ld de, 8                    ;skip padding
add hl, de
ld a, 2                     
call DRAW_SPRITE_COLUMN     ;create second column

pop bc                      ;restore col/row
inc b                       ;next col
ld de, 8                    ;skip padding
add hl, de
ld a, 2
call DRAW_SPRITE_COLUMN     ;create last column

ret

VERTICAL_SHIFT:

srl b                       ;calculate row/col
srl c

ex de, hl
ld a, 3
push bc
call DRAW_SPRITE_COLUMN     ;draw first row

ld a, 3
pop bc
inc b
call DRAW_SPRITE_COLUMN     ;draw second row

ret
ENDP

#endif

#ifdef ENABLE_PRINT

PROC
PRINT_CHAR:               ;input: a = char number, c = color, e = x, l = y, trashes bc, de, hl, a


HL_POW2_5()              ;y * 32

add hl, de              ;+ x

ex de, hl

ld hl, $5800
add hl, de
ld (hl), c              ;set tile color


ld l, a                 ;get tile source address
ld h, 0

HL_POW2_3()

ld bc, ROM_CHARSET
add hl, bc


ld a, d                 ;calculate screen address
rla
rla
rla
or %01000000
ld d, a

ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d

ld a, (hl)
ld (de), a

ret
ENDP

#endif

#ifdef ENABLE_TILES
PROC
SET_TILEMAP:            ;input: hl = tile set address, trashes de, hl

ld de, TILE_SET
ex de, hl
WRITE_HL_POINTER(d,e)

ret
ENDP

PROC
SET_TILE:               ;input: a = tile number, c = color, e = x, l = y, trashes bc, de, hl, a


HL_POW2_5()              ;y * 32

add hl, de              ;+ x

ex de, hl

ld hl, TILE_MAP
add hl, de              ;+ tile_map address

ld (hl), a              ;set tile number

ld hl, $5800
add hl, de
ld (hl), c              ;set tile color


ld l, a                 ;get tile source address
ld h, 0

HL_POW2_3()

ld bc, (TILE_SET)
add hl, bc


ld a, d                 ;calculate screen address
rla
rla
rla
or %01000000
ld d, a

ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d

ld a, (hl)
ld (de), a

ret
ENDP

PROC
SET_TILE_COLOR:              ;input: c = color, e = x, l = y, trashes bc, de, hl, a


HL_POW2_5()              ;y * 32

add hl, de              ;+ x
ex de, hl
ld hl, $5800
add hl, de
ld (hl), c              ;set tile color

ret

ENDP

PROC
GET_TILE_COLOR:              ;input: e = x, l = y, trashes de, hl, a, output: a = color


HL_POW2_5()              ;y * 32

add hl, de              ;+ x
ex de, hl
ld hl, $5800
add hl, de
ld a, (hl)

ret

ENDP

PROC
LOCAL REAL_OP, NO_OP, END_SET

SET_TILE_CHECKED:       ;input: a = tile number, c = color, e = x, l = y, trashes bc, de, hl, a

HL_POW2_5()             ;y * 32

add hl, de              ;+ x

push hl                 ;store displacement for later check of clear ops

ex de, hl

ld hl, TILE_MAP
add hl, de              ;+ tile_map address

ld (hl), a              ;set tile number

ld hl, $5800
add hl, de
ld (hl), c              ;set tile color


ld l, a                 ;get tile source address
ld h, 0

HL_POW2_3()

ld bc, (TILE_SET)
add hl, bc

push hl                 ;store tile source address for later check

pop bc                                  ;tile source address
pop hl                                  ;displacement

push hl
push de
push bc                                ;preserve tile source address

ld de, (CURRENT_DRAW_MAP)

add hl, de                             ;advance pointer to concrete cell

ld a, (hl)
and a
jp z, NO_OP                            ;a = num op

REAL_OP:

dec a

ld l, a
ld h, 0

COPY_16B_REG(h,l, d,e)
HL_POW2_2()
add hl, de                                  ;hl = offset, a = numop

ld bc, (CURRENT_DRAW_OPS)

add hl, bc                                  ;get current op address

inc hl
inc hl

pop de

WRITE_HL_POINTER(d, e)

ld a, 2
ld (hl), a

pop de                                  ;cleanup
pop de                                  ;cleanup

jp END_SET

NO_OP:

pop hl
pop de
pop bc

ld a, d                 ;calculate screen address
rla
rla
rla
or %01000000
ld d, a

ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d
ld a, (hl)
    ld (de), a
    inc hl
    inc d

ld a, (hl)
ld (de), a

END_SET:

ret
ENDP

PROC
GET_TILE:               ;input: de = x, hl = y, trashes de, hl, a

HL_POW2_5()              ;y * 32

add hl, de              ;+ x

ex de, hl

ld hl, TILE_MAP
add hl, de              ;+ tile_map address

ld a, (hl)              ;get tile number

ret
ENDP

#endif

GSPRITES_LIB_END:

end asm


sub InitGFXLib()

asm

    call INIT_GFX_LIB

end asm

end sub

sub ResetGFXLib()

asm

    call RESET_GFX_LIB

end asm

end sub

sub RenderFrame()

asm

    call RENDER_FRAME

end asm

end sub

#ifdef ENABLE_1x1_SPRITES

#ifndef PRECOMPUTED_SPRITES

function fastcall Create1x1Sprite(SpriteAddress as uInteger) as uByte

asm

    push ix
    push iy
    call CREATE_1x1_SPRITE
    pop iy
    pop ix

end asm

end function

#endif

sub fastcall Draw1x1Sprite(SpriteNumber as uByte, X as uByte, Y as uByte)

asm

    exx
    pop hl
    exx
    pop bc
    pop de
    exx
    push hl
    exx

    push ix
    push iy
    ld c, d
    call DRAW_1x1_SPRITE
    pop iy
    pop ix

end asm

end sub

#endif

#ifdef ENABLE_1x2_SPRITES

#ifndef PRECOMPUTED_SPRITES

function fastcall Create1x2Sprite(SpriteAddress as uInteger) as uByte

asm

    push ix
    push iy
    call CREATE_1x2_SPRITE
    pop iy
    pop ix

end asm

end function

#endif

sub fastcall Draw1x2Sprite(SpriteNumber as uByte, X as uByte, Y as uByte)

asm

    exx
    pop hl
    exx
    pop bc
    pop de
    exx
    push hl
    exx
    push ix
    push iy
    ld c, d
    call DRAW_1x2_SPRITE
    pop iy
    pop ix

end asm

end sub

#endif

#ifdef ENABLE_2x2_SPRITES

#ifndef PRECOMPUTED_SPRITES

function fastcall Create2x2Sprite(SpriteAddress as uInteger) as uByte

asm

    push ix
    push iy
    call CREATE_2x2_SPRITE
    pop iy
    pop ix

end asm

end function

#endif

sub fastcall Draw2x2Sprite(SpriteNumber as uByte, X as uByte, Y as uByte)

asm

    exx
    pop hl
    exx
    pop bc
    pop de
    exx
    push hl
    exx
    push ix
    push iy
    ld c, d
    call DRAW_2x2_SPRITE
    pop iy
    pop ix

end asm

end sub

#endif

sub fastcall CancelOps()

    asm
    xor a
    ld (CURRENT_DRAW_COUNT), a
    ld (CURRENT_CLEAR_COUNT), a
    end asm

end sub

sub ClearScreen(NewInk as uByte, NewPaper as uByte, NewBright as uByte)

    ink NewInk
    paper NewPaper
    bright NewBright
    cls

    asm
    call CLEAR_SCREEN
    end asm

end sub

#ifdef ENABLE_PRINT

sub PrintString(text as string, Color as uInteger, X as uInteger, Y as uInteger)

    Dim buc as uByte
    Dim tmpVal as uByte = len(text)

    for buc = 1 to tmpVal
        PrintChar(code(text(buc to buc)), Color, X + buc - 1, Y)
    next buc 

end sub

sub fastcall PrintChar(CharNumber as uByte, Color as uInteger, X as uInteger, Y as uInteger)

asm
    exx
    pop hl
    exx
    pop bc
    pop de
    pop hl
    exx
    push hl
    exx
    call PRINT_CHAR
end asm

end sub

#endif

#ifdef ENABLE_TILES

sub fastcall SetTileset(TileSet as uInteger)

asm
    call SET_TILEMAP
end asm

end sub

sub fastcall SetTile(TileNumber as uByte, Color as uInteger, X as uInteger, Y as uInteger)

asm
    exx
    pop hl
    exx
    pop bc
    pop de
    pop hl
    exx
    push hl
    exx
    call SET_TILE
end asm

end sub

sub fastcall SetTileColor(X as uInteger, Y as uInteger, Color as uInteger)

asm
    exx
    pop hl
    exx
    pop de
    pop bc
    ex de, hl
    exx
    push hl
    exx
    call SET_TILE_COLOR
end asm

end sub

sub fastcall SetTileChecked(TileNumber as uByte, Attribute as uInteger, X as uInteger, Y as uInteger)

asm
    exx
    pop hl
    exx
    pop bc
    pop de
    pop hl
    exx
    push hl
    exx
    call SET_TILE_CHECKED
end asm

end sub

function fastcall GetTile(X as uInteger, Y as uInteger) as uByte

asm
    pop bc
    pop de
    push bc
    ex de, hl
    call GET_TILE
end asm

end function


function fastcall GetTileColor(X as uInteger, Y as uInteger) as uByte

asm
    pop bc
    pop de
    push bc
    ex de, hl
    call GET_TILE_COLOR
end asm

end function

sub SetTiledObject(ObjectTileIndex as uByte, Width as uByte, Height as uByte, Attribute as uByte, X as uByte, Y as uByte)

    Dim tmpX as uByte
    Dim tmpY as uByte

    for tmpX = X to X + Width - 1
        for tmpY = Y to Y + Height - 1
            SetTile(ObjectTileIndex, Attribute, tmpX, tmpY)
            ObjectTileIndex = ObjectTileIndex + 1
        next tmpY
    next tmpX

end sub

sub FillWithTile(TileIndex as uByte, Width as uByte, Height as uByte, Attribute as uByte, X as uByte, Y as uByte)

    Dim tmpX as uByte
    Dim tmpY as uByte

    for tmpX = X to X + Width - 1
        for tmpY = Y to Y + Height - 1
            SetTile(TileIndex, Attribute, tmpX, tmpY)
        next tmpY
    next tmpX

end sub

sub SetTiledObjectChecked(ObjectTileIndex as uByte, Width as uByte, Height as uByte, Attribute as uByte, X as uByte, Y as uByte)

    Dim tmpX as uByte
    Dim tmpY as uByte

    for tmpX = X to X + Width - 1
        for tmpY = Y to Y + Height - 1
            SetTileChecked(ObjectTileIndex, Attribute, tmpX, tmpY)
            ObjectTileIndex = ObjectTileIndex + 1
        next tmpY
    next tmpX

end sub

sub FillWithTileChecked(TileIndex as uByte, Width as uByte, Height as uByte, Attribute as uByte, X as uByte, Y as uByte)

    Dim tmpX as uByte
    Dim tmpY as uByte

    for tmpX = X to X + Width - 1
        for tmpY = Y to Y + Height - 1
            SetTileChecked(TileIndex, Attribute, tmpX, tmpY)
        next tmpY
    next tmpX

end sub

#endif